---
layout:     post   				    # 使用的布局（不需要改）
title:      人工智能-搜索策略			    # 标题 
subtitle:                 #副标题
date:       2020-02-02	# 时间
author:     Btbsja					# 作者
header-img: img/bg-2020-01-27.jpg 	    #这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签

    - 人工智能

---

# 搜索策略

## 一、实验内容

1.  熟悉和掌握启发式搜索的定义、估价函数和算法过程，比较不同算法的性能。

2.  以八数码问题或路径规划等问题为例设计启发式搜索算法，改变启发函数，观察结果的变化，分析原因。

## 二、实验目的

熟悉和掌握各种启发式搜索策略的思想，掌握A\*算法的定义、估价函数和算法过程，理解求解流程和搜索顺序。

## 三、实验内容

1、分别以各种搜索算法为例演示搜索过程，比较不同算法的性能；

2、分析各种算法中的OPEN表CLOSE表的生成过程；

3、分析估价函数对搜索算法的影响；

4、修改八数码问题或路径规划问题的源程序，改变其启发函数定义，观察结果的变化，分析原因。

## 四、实验环境

1.  搜索策略可视化实验环境，如图1所示。

2.  C＋＋语言编程环境，语言环境可以自选。

> ![](https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309103416.png){width="5.736111111111111in" height="2.7777777777777777in"}图1 搜索策略可视化实验环境

## 五、实验步骤

1、开始演示。进入搜索策略演示程序，可从多种不同搜索算法选择装载相关源文件；

2、选择不同的搜索算法，点击"autosearch" 观察搜索过程；

3、设置不同属性，观察搜索过程的变化；

4、观察运行过程和搜索顺序，理解启发式搜索的原理；

5、算法流程的任一时刻的相关状态,以算法流程高亮、open表、close表、节点静态图、当前扩展节点移动图等5种形式在按钮上方同步显示,便于深入学习理解搜索算法。

6、根据程序运行过程画出搜索算法框图；

7、若要自己设计改进算法并运行，可参考帮助文件。

8、任选给定的两个源代码之一，修改其估价函数的定义，对比修改前和修改后的结果，并对结果进行分析。

## 六、实验结论

包括做实验的目的、方法、过程等，具体要写成实验报告，见后附表一。

1、启发式搜索算法A\*流程图和算法框图；

2、试分析估价函数的值对搜索算法速度的影响；

3、根据A\*算法分析启发式搜索的特点。

4、八数码问题或路径规划问题的源程序修改后的启发函数说明，运行结果对比分析。

## 附：搜索策略实验报告表一

| 实验目的         | 熟悉和掌握启发式搜索的定义、估价函数和算法过程，并利用A*算法求解N数码难题，理解求解流程和搜索顺序。 |                                                              |                                                              |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 搜索图           | 使用的是实验环境中已经建立好的“多重路径修建”搜索图           |                                                              |                                                              |
| 算法比较         | 深度优先                                                     | Best First（贪婪算法）                                       | A*算法                                                       |
| Open表           | ![image-20200309103715680](https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309104452.png) | ![image-20200309103739909](https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309104453.png) | ![image-20200309103752164](https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309104454.png) |
| Close表          | ![image-20200309103809073](https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309104455.png) | ![image-20200309103822277](https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309104456.png) | ![image-20200309103829656](https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309104457.png) |
| 估价函数         | f(x)=g(x)                                                    | f(x)=h(x)                                                    | f(x)=g(x)*+h(x)*                                             |
| 搜索节点次序记录 | 0->1->3->4->2->4->  6->4->7->5->6->8                         | 0->1->3->4->2->4->6->4->7->5->6->8                           | 0->1->3->4->2->4->6->5->7->6->8                              |
| 观测结果         | 最终路径是  0->4->8                                          | 最终路径是  0->4->8                                          | 最终路径是  0->4->8                                          |
| 学生结论         | 广度优先搜索算法是一种搜索策略，与之相对应的还有深度优先搜索算法。广度优先是指从图G中 的某点为始点出发，标记出所有与之相邻的点，并再以所有与之相邻的点为始点，搜索所有与这些点相邻的点，从而逐层向下扩展，实现对图的遍历。同理，深度优 先搜索是指从某点出发，逐层向下扩展，直到无路可扩展时向上回溯，它是优先考虑图的深度（指从某点的扩展深度），而广度优先则优先考虑图的广度（指从某点 的可扩展量）。 | 贪婪算法是一种不追求最优解，只希望得到较为满意解的方法。贪婪算法一般可以快速得到满意的解，因为它省去了为找最优解要穷尽所有可能而必须耗费的大量时间。贪婪算法常以当前情况为基础作最优选择，而不考虑各种可能的整体情况，所以贪婪法不要回溯。 | A*算法结合了启发式方法（这种方法通过充分利用图给出的信息来动态地作出决定而使搜索次数大大降低）和形式化方法（这种方法不利用图给出的信息，而仅通过数学的形式分析，如Dijkstra算法）。它通过一个估价函数（Heuristic Function）f(h)来估计图中的当前点p到终点的距离(带权值)，并由此决定它的搜索方向，当这条路径失败时，它会尝试其它路径。  我们说如果在一般的图搜索算法中应用了上面的估价函数对OPEN表进行排序的，就称A算法。在A算法之上，如果加上一个条件，对于所有的结点x，都有h(x)<=h*(x)，那就称为A*算法。如果取h(n)=0同样是A*算法，这样它就退化成了有序算法。  A*算法是否成功，也就是说是否在效率上胜过蛮力搜索算法，就在于h(n)的选取，它不能大于实际的h*(n)，要保守一点，但越接近h*(n)给我们的启发性就越大，是一个难把握的东西。 |

## 数码问题

八数码问题原本的启发式函数为

![](https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309104458.png){width="1.333167104111986in" height="3.9161767279090114in"}![](https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309104459.png){width="1.1769356955380577in" height="0.1874770341207349in"}![](https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309104500.png){width="1.832638888888889in" height="0.40555555555555556in"}

**算法改进后**

![](https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309104501.png){width="4.259884076990376in" height="0.26038385826771654in"}

![](https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309104502.png){width="0.8853062117235345in" height="0.22913823272090988in"}

![](https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309104503.png){width="1.9580883639545057in" height="5.540974409448819in"}

**由上述分析可得**原本的前继与后继的积分作为启发式函数的效果明显好于修改之后的欧式距离。

