I".<h1 id="3-次握手4-次挥手">3 次握手/4 次挥手</h1>

<p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。即客户端和服务器的内存里保存的一份关于对方的信息，如 ip 地址、端口号等。</p>

<p>TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。</p>

<p>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 4 次挥手来关闭一个连接。</p>

<h2 id="tcp-服务模型">TCP 服务模型</h2>

<p>一个 TCP 连接由一个 4 元组构成，分别是两个 IP 地址和两个端口号。</p>

<p>一个 TCP 连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p>

<p>当 TCP 接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK（ACK的全称为Acknowledge character，即确认字符，表示接收到的字符无错误。） 是累积的，一个确认字节号 N 的 ACK 表示所有直到 N 的字节（不包括 N）已经成功被接收了。这样的好处是如果一个 ACK 丢失，很可能后续的 ACK 就足以确认前面的报文段了。</p>

<p>一个完整的 TCP 连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种<strong>双工服务</strong>。一旦建立了一个连接，这个连接的一个方向上的每个 TCP 报文段都包含了相反方向上的报文段的一个 ACK。</p>

<p>序列号的作用是使得一个 TCP 接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为 TCP 使用 IP 来传输报文段，而 IP 不提供重复消除或者保证次序正确的功能。另一方面，TCP 是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此 TCP 接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p>

<h2 id="tcp-头部">TCP 头部</h2>

<p><img src="https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200322212424.png" alt="image-20200317091333784" /></p>

<p>源端口和目的端口在 TCP 层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK 表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加 1，这个字段只有在 ACK 位被启用的时候才有效。</p>

<p>当新建一个连接时，从客户端发送到服务端的第一个报文段的 SYN 位被启用，这称为 SYN 报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号<code class="highlighter-rouge">ISN</code>，之后发送的数据是 ISN 加 1，因此 SYN 位字段会<code class="highlighter-rouge">消耗</code>一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的 ACK 则不是。</p>

<p>头部长度（图中的数据偏移）以 32 位字为单位，也就是以 4bytes 为单位，它只有 4 位，最大为 15，因此头部最大长度为 60 字节，而其最小为 5，也就是头部最小为 20 字节（可变选项为空）。</p>

<p>ACK —— 确认，使得确认号有效。 RST —— 重置连接（经常看到的 reset by peer）就是此字段搞的鬼。 SYN —— 用于初如化一个连接的序列号。 FIN —— 该报文段的发送方已经结束向对方发送数据。</p>

<p>当一个连接被建立或被终止时，交换的报文段只包含 TCP 头部，而没有数据。</p>

<h2 id="状态转换">状态转换</h2>

<p><img src="https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200322212425.jpg" alt="1" /></p>

<h2 id="为什么要-三次握手四次挥手">为什么要 “三次握手，四次挥手”</h2>

<h3 id="三次握手">三次握手</h3>

<p>客户端和服务端通信前要进行连接，“3 次握手” 的作用就是<code class="highlighter-rouge">双方都能明确自己和对方的收、发能力是正常的</code>。</p>

<p><code class="highlighter-rouge">第一次握手</code>：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>

<p><code class="highlighter-rouge">第二次握手</code>：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p>

<p><code class="highlighter-rouge">第三次握手</code>：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p>

<p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p>

<p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的 “响应” 是由于第一次的 “请求” 触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p>

<p>用表格总结一下：</p>

<p><img src="https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200322212426.jpg" alt="" /></p>

<h2 id="四次挥手">四次挥手</h2>

<p>TCP 连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个 ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK 确认关闭连接。注意，接收到 FIN 报文的一方只能回复一个 ACK, 它是无法马上返回对方一个 FIN 报文段的，因为结束数据传输的 “指令” 是上层应用层给出的，我只是一个“搬运工”，我无法了解<code class="highlighter-rouge">“上层的意志”</code>。</p>

<h2 id="三次握手四次挥手-怎么完成">“三次握手，四次挥手” 怎么完成？</h2>

<p>其实 3 次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号 ISN。</p>

<p>3 次握手是指发送了 3 个报文段，4 次挥手是指发送了 4 个报文段。注意，SYN 和 FIN 段都是会利用重传进行可靠传输的。</p>

<h2 id="三次握手-1">三次握手</h2>

<ol>
  <li>客户端发送一个 SYN 段，并指明客户端的初始序列号，即 ISN(c).</li>
  <li>服务端发送自己的 SYN 段作为应答，同样指明自己的 ISN(s)。为了确认客户端的 SYN，将 ISN(c)+1 作为 ACK 数值。这样，每发送一个 SYN，序列号就会加 1. 如果有丢失的情况，则会重传。</li>
  <li>为了确认服务器端的 SYN，客户端将 ISN(s)+1 作为返回的 ACK 数值。</li>
</ol>

<h2 id="四次挥手-1">四次挥手</h2>

<ol>
  <li>客户端发送一个 FIN 段，并包含一个希望接收者看到的自己当前的序列号 K. 同时还包含一个 ACK 表示确认对方最近一次发过来的数据。 2. 服务端将 K 值加 1 作为 ACK 序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。 3. 服务端发起自己的 FIN 段，ACK=K+1, Seq=L 4. 客户端确认。ACK=L+1</li>
</ol>

<h2 id="为什么建立连接是三次握手而关闭连接却是四次挥手呢">为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h2>

<p>这是因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 ACK 和 FIN 一般都会分开发送。</p>

<h2 id="三次握手四次挥手-进阶">“三次握手，四次挥手” 进阶</h2>

<h2 id="isn">ISN</h2>

<p>三次握手的一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p>

<p>如果 ISN 是固定的，攻击者很容易猜出后续的确认号。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ISN = M + F(localhost, localport, remotehost, remoteport)
</code></pre></div></div>

<p>M 是一个计时器，每隔 4 毫秒加 1。 F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 hash 算法不能被外部轻易推算得出。</p>

<h2 id="序列号回绕">序列号回绕</h2>

<p>因为 ISN 是随机的，所以序列号容易就会超过 2^31-1. 而 tcp 对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的 tcp 序列号回绕（sequence wraparound）问题。怎么解决？</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
The next routines deal with comparing 32 bit unsigned ints
and worry about wraparound (automatic with unsigned arithmetic).
*/
static inline int before(__u32 seq1, __u32 seq2)
{
    return (__s32)(seq1-seq2) &lt; 0;
}

#define after(seq2, seq1) before(seq1, seq2)
</code></pre></div></div>

<p>上述代码是内核中的解决回绕问题代码。<strong>s32 是有符号整型的意思，而</strong> u32 则是无符号整型。序列号发生回绕后，序列号变小，相减之后，把结果变成有符号数了，因此结果成了负数。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>假设seq1=255， seq2=1（发生了回绕）。
seq1 = 1111 1111 seq2 = 0000 0001
我们希望比较结果是
 seq1 - seq2=
 1111 1111
-0000 0001
-----------
 1111 1110

由于我们将结果转化成了有符号数，由于最高位是1，因此结果是一个负数，负数的绝对值为
 0000 0001 + 1 = 0000 0010 = 2

因此seq1 - seq2 &lt; 0
</code></pre></div></div>

:ET