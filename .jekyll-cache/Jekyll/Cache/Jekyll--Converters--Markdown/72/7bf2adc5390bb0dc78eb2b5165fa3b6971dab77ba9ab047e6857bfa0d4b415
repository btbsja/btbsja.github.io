I"ãw<h1 id="slråˆ†ææ³•">SLRåˆ†ææ³•</h1>

<h2 id="1å®éªŒç›®çš„">1.å®éªŒç›®çš„</h2>

<p>äº†è§£SLRè¯­æ³•åˆ†æç®—æ³•çš„åŸºæœ¬æ€æƒ³ï¼ŒæŒæ¡SLRè¯­æ³•åˆ†æç¨‹åºçš„æ„é€ æ–¹æ³•ã€‚</p>

<h2 id="2è®¾è®¡æ–¹æ³•">2.è®¾è®¡æ–¹æ³•</h2>

<h3 id="21å®éªŒåŸç†">2.1å®éªŒåŸç†</h3>

<p>SLRæ–‡æ³•åˆ†ææ³•å°±æ˜¯å¯¹LR(0)çš„ä¸€ç§ä¼˜åŒ–</p>

<p>SLRæ–‡æ³•æ„é€ åˆ†æè¡¨çš„ä¸»è¦æ€æƒ³æ˜¯ï¼šè®¸å¤šå†²çªæ€§çš„åŠ¨ä½œéƒ½å¯èƒ½é€šè¿‡è€ƒå¯Ÿæœ‰å…³éç»ˆç»“ç¬¦çš„FOLLOWé›†è€Œè·è§£å†³ã€‚</p>

<p>è§£å†³å†²çªçš„æ–¹æ³•ï¼šè§£å†³å†²çªçš„æ–¹æ³•æ˜¯åˆ†ææ‰€æœ‰å«Aå’ŒBçš„å¥å‹ï¼Œè€ƒå¯Ÿé›†åˆFOLLOW(A)å’ŒFOLLOW(B)ï¼Œå¦‚æœè¿™ä¸¤ä¸ªé›†åˆä¸ç›¸äº¤ï¼Œè€Œä¸”ä¹Ÿä¸åŒ…å«bï¼Œé‚£ä¹ˆå½“çŠ¶æ€Ié¢ä¸´è¾“å…¥ç¬¦å·aæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¦‚ä¸‹ç­–ç•¥ï¼š</p>

<p>è‹¥a=bï¼Œåˆ™ç§»è¿›ã€‚</p>

<p>è‹¥aâˆˆFOLLOW(A)ï¼Œåˆ™ç”¨äº§ç”Ÿå¼Aâ†’Î±è¿›è¡Œå½’çº¦ï¼›</p>

<p>è‹¥aâˆˆFOLLOW(B)ï¼Œåˆ™ç”¨äº§ç”Ÿå¼Bâ†’Î±è¿›è¡Œå½’çº¦ï¼›</p>

<p>æ­¤å¤–ï¼ŒæŠ¥é”™*</p>

<p>SLRçš„åŸºæœ¬ç®—æ³•ï¼š</p>

<p>å‡å®šLR(0)è§„èŒƒæ—çš„ä¸€ä¸ªé¡¹ç›®é›†Iä¸­å«æœ‰mä¸ªç§»è¿›é¡¹ç›®</p>

<p>A1â†’Î±â€¢a1Î²1ï¼ŒA2â†’Î±â€¢a2Î²2ï¼Œâ€¦ï¼ŒAmâ†’Î±â€¢amÎ²mï¼›</p>

<p>åŒæ—¶å«æœ‰nä¸ªå½’çº¦é¡¹ç›®</p>

<p>B1â†’Î±â€¢ï¼ŒB2â†’Î±â€¢ï¼Œâ€¦ï¼ŒB3â†’Î±â€¢ï¼Œ</p>

<p>å¦‚æœé›†åˆ{ a1,â€¦, am}ï¼ŒFOLLOW(B1)ï¼Œâ€¦ï¼ŒFOLLOW(Bn)ä¸¤ä¸¤ä¸ç›¸äº¤ï¼ˆåŒ…æ‹¬ä¸å¾—æœ‰ä¸¤ä¸ªFOLLOWé›†åˆæœ‰#ï¼‰ï¼Œåˆ™éšå«åœ¨Iä¸­çš„åŠ¨ä½œå†²çªå¯ä»¥é€šè¿‡æ£€æŸ¥ç°è¡Œè¾“å…¥ç¬¦å·aå±äºä¸Šè¿°n+1ä¸ªé›†åˆä¸­çš„å“ªä¸ªé›†åˆè€Œæ´»çš„è§£å†³ï¼š</p>

<p>è‹¥aæ˜¯æŸä¸ªaiï¼Œi=1,2,â€¦,mï¼Œåˆ™ç§»è¿›ã€‚</p>

<p>è‹¥aâˆˆFOLLOW(Bi)ï¼Œi=1,2,â€¦,mï¼Œåˆ™ç”¨äº§ç”Ÿå¼Biâ†’Î±è¿›è¡Œå½’çº¦ï¼›</p>

<p>æ­¤å¤–ï¼ŒæŠ¥é”™</p>

<p>è¿™ç§å†²çªçš„è§£å†³æ–¹æ³•å«åšSLR(1)è§£å†³åŠæ³•ã€‚</p>

<p>SLRè¯­æ³•åˆ†æè¡¨çš„æ„é€ æ–¹æ³•ï¼š</p>

<p>é¦–å…ˆæŠŠGæ‹“å¹¿ä¸ºGâ€™ï¼Œå¯¹Gâ€™æ„é€ LR(0)é¡¹ç›®é›†è§„èŒƒæ—Cå’Œæ´»å‰ç¼€è¯†åˆ«è‡ªåŠ¨æœºçš„çŠ¶æ€è½¬æ¢å‡½æ•°GOã€‚å‡½æ•°ACTIONå’ŒGOTOå¯æŒ‰å¦‚ä¸‹æ–¹æ³•æ„é€ ï¼š</p>

<p>è‹¥é¡¹ç›®Aâ†’Î±â€¢bÎ²å±äºIkï¼ŒGO(Ik,a)= Ij,aä¸ºç»ˆç»“ç¬¦ï¼Œç½®ACTION[k,a]ä¸ºâ€æŠŠçŠ¶æ€jå’Œç¬¦å·aç§»è¿›æ ˆâ€ï¼Œç®€è®°ä¸ºâ€sjâ€ï¼›</p>

<p>è‹¥é¡¹ç›®Aâ†’Î±â€¢å±äºIkï¼Œé‚£ä¹ˆï¼Œå¯¹ä»»ä½•éç»ˆç»“ç¬¦aï¼ŒaâˆˆFOLLOW(A)ï¼Œç½®ACTION[k,a]ä¸ºâ€ç”¨äº§ç”Ÿå¼Aâ†’Î±è¿›è¡Œå½’çº¦â€ï¼Œç®€è®°ä¸ºâ€rjâ€ï¼›å…¶ä¸­ï¼Œå‡å®šAâ†’Î±ä¸ºæ–‡æ³•Gâ€™çš„ç¬¬jä¸ªäº§ç”Ÿå¼</p>

<p>è‹¥é¡¹ç›®Sâ€™â†’Sâ€¢å±äºIkï¼Œåˆ™ç½®ACTION[k,#]ä¸ºå¯â€æ¥å—â€ï¼Œç®€è®°ä¸ºâ€accâ€ï¼›</p>

<p>è‹¥GO(Ik, A)= Ijï¼ŒAä¸ºéç»ˆç»“ç¬¦ï¼Œåˆ™ç½®GOTO[k, A]=jï¼›</p>

<p>åˆ†æè¡¨ä¸­å‡¡ä¸èƒ½ç”¨è§„åˆ™1è‡³4å¡«å…¥ä¿¡æ¯çš„ç©ºç™½æ ¼å‡å¡«ä¸Šâ€å‡ºé”™æ ‡å¿—â€ã€‚</p>

<p>è¯­æ³•åˆ†æå™¨çš„åˆå§‹çŠ¶æ€æ˜¯åŒ…å«Sâ€™ â†’â€¢Sçš„é¡¹ç›®é›†åˆçš„çŠ¶æ€</p>

<p>SLRè§£å†³çš„å†²çªåªæ˜¯ç§»è¿›-è§„çº¦å†²çªå’Œè§„çº¦-è§„çº¦å†²çª</p>

<h3 id="22ç¨‹åºæµç¨‹å›¾">2.2ç¨‹åºæµç¨‹å›¾</h3>

<p><img src="https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309093336.png" alt="" />{width=â€4.983333333333333inâ€ height=â€4.125inâ€}</p>

<h2 id="3å®éªŒå†…å®¹">3.å®éªŒå†…å®¹</h2>

<p>è¾“å…¥æ–‡æ³•ï¼š</p>

<p>S.  &gt;EÂ <br />
    E-&gt;E+TÂ <br />
    E-&gt;TÂ <br />
    T-&gt;T*FÂ <br />
    T-&gt;FÂ <br />
    F-&gt;(E)Â <br />
    F-&gt;i</p>

<p>ç”Ÿæˆçš„é¡¹ç›®è¡¨</p>

<p><img src="https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309093337.png" alt="" />{width=â€4.5375inâ€ height=â€2.9784722222222224inâ€}</p>

<p>éç»ˆç»“ç¬¦çš„First followé›†åˆ</p>

<p><img src="https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309093338.png" alt="" />{width=â€5.233333333333333inâ€ height=â€1.7416666666666667inâ€}</p>

<p>é¡¹ç›®è§„èŒƒæ—</p>

<p><img src="https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309093339.png" alt="" />{width=â€4.883333333333334inâ€ height=â€7.991666666666666inâ€}</p>

<p>æ„é€ å‡ºçš„DFA</p>

<p><img src="https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309093340.png" alt="" />{width=â€4.4inâ€ height=â€3.8inâ€}</p>

<p>SLRæ–‡æ³•è¡¨å’Œä¸€ä¸ªä¾‹å­çš„æ–‡æ³•åˆ†æè¿‡ç¨‹</p>

<p><img src="https://gitee.com/btbsja/BlogImg/raw/master/blog/2020/03/20200309093341.png" alt="" />{width=â€5.767361111111111inâ€ height=â€3.576388888888889inâ€}</p>

<h2 id="4å®éªŒæ€»ç»“">4.å®éªŒæ€»ç»“</h2>

<p>æœ¬å®éªŒç¨‹åºè¾ƒå¥½åœ°å®Œæˆäº†SLR(1)åˆ†ææ³•åˆ†æç¨‹åºçš„è®¾è®¡ä¸å®ç°ï¼Œèƒ½å¤Ÿå¯¹æ‰€ç»™å­—ç¬¦ä¸²è¿›è¡Œè¯†åˆ«ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯ç»™å®šæ–‡æ³•çš„å¥å­,ä½†æ˜¯SLRè§£å†³çš„å†²çªåªæ˜¯ç§»è¿›-è§„çº¦å†²çªå’Œè§„çº¦-è§„çº¦å†²çªï¼Œä»éœ€åç»­æ”¹è¿›ã€‚é€šè¿‡è¿™æ¬¡çš„å®éªŒï¼Œæˆ‘äº†è§£äº†LR(0)æ–‡æ³•é¢„æµ‹åˆ†ææ³•è®¾è®¡å’Œå®ç°ï¼ŒåŠ æ·±äº†å¯¹LRï¼ˆ0ï¼‰æ–‡æ³•çš„ç†è§£å’Œè®¤è¯†ï¼Œä½¿æˆ‘çš„ç¼–è¯‘åŸç†çš„çŸ¥è¯†æ›´åŠ å·©å›ºï¼Œè€Œä¸”å¯ä»¥ä½¿ç†è®ºä¸å®è·µç›¸ç»“åˆï¼Œæ›´å¥½çš„æŒæ¡æ‰€å­¦çŸ¥è¯†ã€‚</p>

<h2 id="5æºä»£ç æ¸…å•">5.æºä»£ç æ¸…å•</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#define MAX 507
#define DEBUG
using namespace std;

class WF
{
    public:
    string left,right;
    int back;
    int id;
    WF ( char s1[] , char s2[] , int x , int y )
    {
        left = s1;
        right = s2;
        back = x;
        id = y;
    }
    WF ( const string&amp; s1 , const string&amp; s2 , int x , int y )
    {
        left = s1;
        right = s2;
        back = x;
        id = y;
    }
    bool operator &lt; ( const WF&amp; a ) const 
    {
        if ( left == a.left ) 
            return right &lt; a.right;
        return left &lt; a.left;
    }
    bool operator == ( const WF&amp; a ) const 
    {
        return ( left == a.left )&amp;&amp; ( right == a.right );
    }
    void print ( )
    {
        printf ( "%s-&gt;%s\n" , left.c_str() , right.c_str() );
    }
};

class Closure
{
    public:
    vector&lt;WF&gt; element; 
    void print ( string str )
    {
        printf ( "%-15s%-15s\n" , "" , str.c_str());
        for ( int i = 0 ; i &lt; element.size() ; i++ )
            element[i].print();
    }
    bool operator == ( const Closure&amp; a ) const 
    {
        if ( a.element.size() != element.size() ) return false;
        for ( int i = 0 ; i &lt; a.element.size() ; i++ )
            if ( element[i] == a.element[i] ) continue;
            else return false;
        return true;
    }
};

struct Content
{
    int type;
    int num;
    string out;
    Content(){ type = -1; }
    Content ( int a , int b )
        :type(a),num(b){}
};

vector&lt;WF&gt; wf;
map&lt;string,vector&lt;int&gt; &gt; dic;
map&lt;string,vector&lt;int&gt; &gt; VN_set;
map&lt;string,bool&gt;  vis;
string start = "S";
vector&lt;Closure&gt; collection;
vector&lt;WF&gt; items;
char CH = '$';
int go[MAX][MAX];
int to[MAX];
vector&lt;char&gt; V;
bool used[MAX];
Content action[MAX][MAX];
int Goto[MAX][MAX];
map&lt;string,set&lt;char&gt; &gt; first;
map&lt;string,set&lt;char&gt; &gt; follow;

void make_item ( )
{
    memset ( to , -1 , sizeof ( -1 ) );
    for ( int i = 0 ; i &lt; wf.size() ; i++ )
        VN_set[wf[i].left].push_back ( i );
    for ( int i = 0 ; i &lt; wf.size() ; i++ )
        for ( int j = 0 ; j &lt;= wf[i].right.length() ; j++ )
        {
            string temp = wf[i].right;
            temp.insert ( temp.begin()+j , CH );
            dic[wf[i].left].push_back ( items.size() );
            if ( j )
                to[items.size()-1] = items.size();
            items.push_back ( WF ( wf[i].left , temp , i , items.size()) );
        }
#ifdef DEBUG
    puts("-------------------------é¡¹ç›®è¡¨-------------------------");
    for ( int i = 0 ; i &lt; items.size() ; i++ )
        printf ( "%s-&gt;%s back:%d id:%d\n" , items[i].left.c_str() , items[i].right.c_str() , items[i].back , items[i].id );
    puts("--------------------------------------------------------");
#endif
}

void dfs ( const string&amp; x )
{
    if ( vis[x] ) return;
    vis[x] = 1;
    vector&lt;int&gt;&amp; id = VN_set[x];
    for ( int i = 0 ; i &lt; id.size() ; i++ )
    {
        string&amp; left = wf[id[i]].left;
        string&amp; right = wf[id[i]].right;
        for ( int j = 0 ; j &lt; right.length() ; j++ )
            if ( isupper(right[j] ) )
            {
                dfs ( right.substr(j,1) );
                set&lt;char&gt;&amp; temp = first[right.substr(j,1)];
                set&lt;char&gt;::iterator it = temp.begin();
                bool flag = true;
                for ( ; it != temp.end() ; it++ )
                {
                    if ( *it == '~' ) flag = false;
                    first[left].insert (*it );
                }
                if ( flag ) break;
            }
            else
            {
                first[left].insert ( right[j] );
                break;
            }
    } 
}

void make_first ( )
{
    vis.clear();
    map&lt;string,vector&lt;int&gt; &gt;::iterator it2 = dic.begin();
    for ( ; it2 != dic.end() ; it2++ )
        if ( vis[it2-&gt;first] ) continue;
        else dfs ( it2-&gt;first );
#ifdef DEBUG
    puts ("****************FIRSTé›†***************************");
    map&lt;string,set&lt;char&gt; &gt;::iterator it = first.begin();
    for ( ; it != first.end() ; it++ )
    {
        printf ( "FIRST(%s)={" , it-&gt;first.c_str() );
        set&lt;char&gt; &amp; temp = it-&gt;second;
        set&lt;char&gt;::iterator it1 = temp.begin();
        bool flag = false;
        for ( ; it1 != temp.end() ; it1++ )
        {
            if ( flag ) printf ( "," );
            printf ( "%c" , *it1 );
            flag = true;
        }
        puts ("}" );
    }
#endif 
}

void append ( const string&amp; str1 , const string&amp; str2 )
{
    set&lt;char&gt;&amp; from = follow[str1];
    set&lt;char&gt;&amp; to = follow[str2];
    set&lt;char&gt;::iterator it = from.begin();
    for ( ; it != from.end() ; it++ )
        to.insert ( *it );
}

bool _check ( const vector&lt;int&gt;&amp; id, const string str )
{
    for ( int i = 0 ; i &lt; id.size() ; i++ )
    {
        int x = id[i];
        if ( wf[x].right == str ) return true;
    }
    return false;
}

void make_follow ( )
{
    while ( true )
    {
        bool goon = false;
        map&lt;string,vector&lt;int&gt; &gt;::iterator it2 = VN_set.begin();
        for ( ; it2 != VN_set.end() ; it2++ )
        {
            vector&lt;int&gt;&amp; id = it2-&gt;second;
            for ( int i = 0 ; i &lt; id.size() ; i++ )
            {
                bool flag = true;
                WF&amp; tt = wf[id[i]];
                string&amp; left = tt.left;
                const string&amp; right = tt.right;
                for ( int j = right.length()-1 ; j &gt;= 0 ; j-- )
                    if ( isupper( right[j] ) )
                    {
                        if ( flag )
                        {
                            int tx = follow[right.substr(j,1)].size();
                            append( left , right.substr(j,1) );
                            int tx1 = follow[right.substr(j,1)].size();
                            if ( tx1 &gt; tx ) goon = true;
                            if ( _check ( id , "~" ) )
                                flag = false;           
                        }
                        for ( int k = j+1 ; k &lt; right.length() ; k++ )
                            if ( isupper(right[k] ) )
                            {
                                string idd = right.substr(k,1);
                                set&lt;char&gt;&amp; from = first[idd];
                                set&lt;char&gt;&amp; to = follow[right.substr(j,1)];
                                set&lt;char&gt;::iterator it1 = from.begin();
                                int tx = follow[right.substr(j,1)].size();
                                for ( ; it1 != from.end() ; it1++ )
                                    if ( *it1 != '~' )
                                        to.insert ( *it1 );
                                int tx1 = follow[right.substr(j,1)].size();
                                if ( tx1 &gt; tx ) goon = true;
                                if ( _check ( id , "~" ) )
                                    break;
                            }
                            else
                            {
                                int tx = follow[right.substr(j,1)].size();
                                follow[right.substr(j,1)].insert ( right[k] );
                                int tx1 = follow[right.substr(j,1)].size();
                                if ( tx1 &gt; tx ) goon = true;
                                break;        
                            }
                    }
                    else flag = false;
            }
        }
        if ( !goon ) break;
    }
#ifdef DEBUG
    puts ("***************FOLLOWé›†*******************");
    map&lt;string,set&lt;char&gt; &gt;::iterator it = follow.begin();
    for ( ; it != follow.end() ; it++ )
    {
        printf ( "FOLLOW(%s)={" , it-&gt;first.c_str() );
        set&lt;char&gt; &amp; temp = it-&gt;second;
        //if ( it-&gt;first[0] == 'S' )
            temp.insert ( '#' );
        set&lt;char&gt;::iterator it1 = temp.begin();
        bool flag = false;
        for ( ; it1 != temp.end() ; it1++ )
        {
            if ( flag ) printf ( "," );
            printf ( "%c" , *it1 );
            flag = true;
        }
        puts ("}");
    }
#endif
}


void make_set ( )
{
    bool has[MAX];
    for ( int i = 0 ; i &lt; items.size() ; i++ )
        if ( items[i].left[0] == 'S' &amp;&amp; items[i].right[0] == CH )
        {
            Closure temp;
            string&amp; str = items[i].right;
            vector&lt;WF&gt;&amp; element = temp.element;
            element.push_back ( items[i] );
            int x = 0;
            for ( x = 0 ; x &lt; str.length() ; x++ )
                if ( str[x] == CH )
                    break;
            /*if ( x != str.length()-1 )
            {
                string tt = str.substr(x+1,1);
                vector&lt;int&gt;&amp; id = dic[tt];
                for ( int j = 0 ; j &lt; id.size() ; j++ )
                {
                    int tx = id[j];
                    //items[tx].print();
                    if ( items[tx].right[0] == CH )
                        element.push_back ( items[tx] );
                }
            }*/
            memset ( has , 0 , sizeof ( has ) );
            has[i] = 1;
            if ( x != str.length()-1 )
            {
                queue&lt;string&gt; q;
                q.push( str.substr(x+1,1) );
                while ( !q.empty() )
                {
                    string u = q.front();
                    q.pop();
                    vector&lt;int&gt;&amp; id = dic[u];
                    for( int j = 0 ; j &lt; id.size() ; j++ )
                    {
                        int tx = id[j];
                        if ( items[tx].right[0] == CH )
                        {   
                            if ( has[tx] ) continue;
                            has[tx] = 1;
                            if ( isupper(items[tx].right[1] ) )
                                q.push ( items[tx].right.substr(1,1));
                            element.push_back ( items[tx] );
                        }    
                    }
                }
            }
            collection.push_back ( temp );
        }
    for ( int i = 0 ; i &lt; collection.size() ; i++ )
    {
        map&lt;int,Closure&gt; temp;
        for ( int j = 0 ; j &lt; collection[i].element.size() ; j++ )
        {
            string str = collection[i].element[j].right;
            int x = 0;
            for ( ; x &lt; str.length() ; x++ )
               if ( str[x] == CH ) break;
            if ( x == str.length()-1 ) 
                continue;
            int y = str[x+1];
            int ii;
            //cout &lt;&lt; i &lt;&lt; "previous: " &lt;&lt; str &lt;&lt; endl;
            str.erase ( str.begin()+x);
            str.insert ( str.begin()+x+1 , CH );
            //cout &lt;&lt; i &lt;&lt;"after: " &lt;&lt; str &lt;&lt; endl;
            WF cmp = WF ( collection[i].element[j].left , str , -1 , -1 );
            for ( int k = 0 ; k&lt; items.size() ; k++ )
                if ( items[k] == cmp )
                {
                    ii = k;
                    break;
                }
             //string&amp; str1 = items[ii].right;
             memset ( has , 0 , sizeof ( has ) );
             vector&lt;WF&gt;&amp; element = temp[y].element;
             element.push_back ( items[ii] );
             has[ii] = 1;
             x++;
             /*if ( x != str.length()-1 )
             {
                 string tt = str.substr(x+1,1);
                 vector&lt;int&gt;&amp; id = dic[tt];
                 for ( int j = 0 ; j &lt; id.size() ; j++ )
                 {
                    int tx = id[j];
                    //items[tx].print();
                    if ( items[tx].right[0] == CH )
                        element.push_back ( items[tx] );
                 } 
             }*/
            if ( x != str.length()-1 )
            {
                queue&lt;string&gt; q;
                q.push( str.substr(x+1,1) );
                while ( !q.empty() )
                {
                    string u = q.front();
                    q.pop();
                    vector&lt;int&gt;&amp; id = dic[u];
                    for( int j = 0 ; j &lt; id.size() ; j++ )
                    {
                        int tx = id[j];
                        if ( items[tx].right[0] == CH )
                        {   
                            if ( has[tx] ) continue;
                            has[tx] = 1;
                            if ( isupper(items[tx].right[1] ) )
                                q.push ( items[tx].right.substr(1,1));
                            element.push_back ( items[tx] );
                        }    
                    }
                }
            }
        }
        map&lt;int,Closure&gt;::iterator it = temp.begin();
        for ( ; it != temp.end() ; it++ )
                collection.push_back ( it-&gt;second );
        for ( int i = 0 ; i &lt; collection.size() ; i++ )
            sort ( collection[i].element.begin() , collection[i].element.end() );
        for ( int i = 0 ; i &lt; collection.size() ; i++ )
            for ( int j = i+1 ; j &lt; collection.size() ; j++ )
                if ( collection[i] == collection[j] )
                    collection.erase ( collection.begin()+j );
    }
#ifdef DEBUG
    puts ("-------------CLOSURE---------------------");
    stringstream sin;
    for ( int i = 0 ; i &lt; collection.size() ; i++ )
    {
        sin.clear();
        string out;
        sin &lt;&lt;"closure-I" &lt;&lt; i;
        sin &gt;&gt; out;
        collection[i].print ( out );
    }
    puts("");
#endif  
}

void make_V ( )
{
    memset ( used , 0 , sizeof ( used ) );
    for ( int i = 0 ; i &lt; wf.size() ; i++ )
    {
        string&amp; str = wf[i].left;
        for ( int j = 0 ; j &lt; str.length() ; j++ )
        {
            if ( used[str[j]] ) continue;
            used[str[j]] = 1;
            V.push_back ( str[j] );
        }
        string&amp; str1 = wf[i].right;
        for ( int j = 0 ; j &lt; str1.length() ; j++ )
        {
            if ( used[str1[j]] ) continue;
            used[str1[j]] = 1;
            V.push_back ( str1[j] );
        }
    }
    sort ( V.begin() , V.end() );
    V.push_back ( '#' );
}

void make_cmp ( vector&lt;WF&gt;&amp; cmp1 , int i  , char ch )
{
    for ( int j = 0 ; j &lt; collection[i].element.size() ; j++ )
    {
        string str = collection[i].element[j].right;
        int k;
        for ( k = 0 ; k &lt; str.length() ; k++ )
            if ( str[k] == CH ) 
                break;
        if ( k != str.length() - 1 &amp;&amp; str[k+1] == ch  )
        {
            str.erase ( str.begin()+k);
            str.insert ( str.begin()+k+1 , CH );
            cmp1.push_back ( WF ( collection[i].element[j].left , str , -1 , -1 ) );
        }
    }
    sort ( cmp1.begin() , cmp1.end() );
}

void make_go ( )
{
    memset ( go , -1 , sizeof ( go ) );
    int m = collection.size();
    /*for ( int i = 0 ; i &lt; m ; i++ )
        for ( int j = 0 ; j &lt; collection[i].element.size() ; j++ )
        {
            string left = collection[i].element[j].left;
            string str = collection[i].element[j].right;
            int x = 0;
            for ( ; x &lt; str.length() ; x++ )
               if ( str[x] == CH ) break;
            if ( x == str.length()-1 ) 
                continue;
            int y = str[x+1];
           //cout &lt;&lt; "before : " &lt;&lt; str &lt;&lt; endl;
            str.erase ( str.begin()+x);
            str.insert ( str.begin()+x+1 , CH );
           //cout &lt;&lt; "after : " &lt;&lt; str &lt;&lt; endl;
            WF cmp = WF ( collection[i].element[j].left , str , -1 , -1 );
            for ( int k = 0 ; k &lt; m ; k++ )
            {
                bool flag = false;
                for ( int t = 0 ; t &lt; collection[k].element.size() ; t++ )
                {
                    if ( cmp == collection[k].element[t] )
                    {                        
                        flag = true;
                        break;
                    }
                }
                if ( flag )
                {
                    go[i][y] = k;
                }
            }
        }*/
    for ( int t = 0 ; t &lt; V.size() ; t++ )
    {
        char ch = V[t];
        for ( int i = 0 ; i &lt; m ; i++ )
        {
            vector&lt;WF&gt; cmp1;
            make_cmp ( cmp1 , i , ch );
            cout &lt;&lt; cmp1.size() &lt;&lt; endl;
            if ( cmp1.size() == 0 ) continue;
            for ( int j = 0 ; j &lt; m ; j++ )
            {
                vector&lt;WF&gt; cmp2;
                for ( int k = 0 ; k &lt; collection[j].element.size() ; k++ )
                {
                    string&amp; str = collection[j].element[k].right;
                    int x;
                    for ( x = 0 ; x &lt; str.length() ; x++ )
                        if ( str[x] == CH )
                            break;
                    if ( x &amp;&amp; str[x-1] == ch )
                       cmp2.push_back ( WF( collection[j].element[k].left , str , -1 , -1 ) ); 
                }
                sort ( cmp2.begin() , cmp2.end() );
                cout &lt;&lt; cmp2.size() &lt;&lt; endl;
                bool flag = true;
                if ( cmp2.size() != cmp1.size() ) continue;
                cout &lt;&lt; cmp1.size() &lt;&lt; endl;
                for ( int k = 0 ; k &lt; cmp1.size() ; k++ )
                    if ( cmp1[k] == cmp2[k] ) continue; 
                    else flag = false;
                cout &lt;&lt; "out " &lt;&lt; endl;
                if ( flag ) 
                    go[i][ch] = j;
            }
            //cout &lt;&lt; "YES" &lt;&lt; endl;
        }

    }
#ifdef DEBUG
    puts ("---------------EDGE----------------------");
    stringstream sin;
    string out;
    for ( int i = 0 ; i &lt; m ; i++ )
        for ( int j = 0 ; j &lt; m ; j++ )
            for ( int k = 0 ; k &lt; MAX ; k++ )
                if ( go[i][k] == j )
                {
                    sin.clear();
                    sin &lt;&lt; "I" &lt;&lt; i &lt;&lt; "--" &lt;&lt;(char)(k)&lt;&lt;"--I"&lt;&lt;j;
                    sin &gt;&gt; out;
                    printf ( "%s\n" , out.c_str() );     
                }   
#endif
}

void make_table ( )
{
    memset ( Goto , -1 , sizeof ( Goto ) );
    /*memset ( used , 0 , sizeof ( used ) );
    for ( int i = 0 ; i &lt; wf.size() ; i++ )
    {
        string&amp; str = wf[i].left;
        for ( int j = 0 ; j &lt; str.length() ; j++ )
        {
            if ( used[str[j]] ) continue;
            used[str[j]] = 1;
            V.push_back ( str[j] );
        }
        string&amp; str1 = wf[i].right;
        for ( int j = 0 ; j &lt; str1.length() ; j++ )
        {
            if ( used[str1[j]] ) continue;
            used[str1[j]] = 1;
            V.push_back ( str1[j] );
        }
    }
    sort ( V.begin() , V.end() );
    V.push_back ( '#' );*/
    //write s to the table 
    for( int i = 0 ; i &lt; collection.size() ; i++ )
        for ( int j = 0 ; j &lt; V.size() ; j++ )
        {
            char ch = V[j];
            int x = go[i][ch];
            if ( x == -1 ) continue;
            if ( !isupper(ch) )
                action[i][ch] = Content ( 0 , x );
            else 
                Goto[i][ch] = x;
        }
    //write r and acc to the table 
    for ( int i = 0 ; i &lt; collection.size() ; i++ )
        for ( int j = 0 ; j &lt; collection[i].element.size() ; j++ )
        {
            WF&amp; tt = collection[i].element[j];
            if ( tt.right[tt.right.length()-1] == CH )
            {
                if ( tt.left[0] == 'S' )
                    action[i]['#'] = Content ( 2 , -1 );
                else 
                    for ( int k = 0 ; k &lt; V.size() ; k++ )
                    {
                        int y = V[k];
                        //cout &lt;&lt; "YES " &lt;&lt; endl;
                        //cout &lt;&lt; tt.left &lt;&lt; "-&gt;" &lt;&lt; tt.right &lt;&lt; " " &lt;&lt; tt.back &lt;&lt; endl;
                        if ( !follow[tt.left].count( V[k] ) ) continue;
                       //cout &lt;&lt;tt.left &lt;&lt; "-&gt;" &lt;&lt; tt.right &lt;&lt; " " &lt;&lt;  i &lt;&lt; " " &lt;&lt; V[k] &lt;&lt; " " &lt;&lt; tt.back &lt;&lt; endl;
                        action[i][y] = Content ( 1, tt.back );
                    }
            }
        }
#ifdef DEBUG
    puts ( "------------------------------------------LR(0)åˆ†æè¡¨--------------------------------------------------------" );
    printf ( "%10s%5c%5s" , "|" , V[0]  , "|");
    for ( int i = 1 ; i &lt; V.size() ; i++ )
        printf ( "%5c%5s" , V[i] , "|" );
    puts ("");
    for ( int i = 0 ; i &lt; (V.size()+1)*10 ; i++ )
        printf ( "-" );
    puts("");
    stringstream sin;
    for ( int i = 0 ; i &lt; collection.size() ; i++ )
    {
        printf ( "%5d%5s" , i , "|" );
        for ( int j = 0 ; j &lt; V.size() ; j++ )
        {
            char ch = V[j];
            if ( isupper(ch) )
            {
                if ( Goto[i][ch] == -1 )
                    printf ( "%10s" , "|" );
                else 
                    printf ( "%5d%5s" , Goto[i][ch] , "|" );
            }
            else
            {
                sin.clear();
                if ( action[i][ch].type == -1 ) 
                    printf ( "%10s" , "|" ); 
                else 
                {
                    Content&amp; temp = action[i][ch];
                    if ( temp.type == 0 ) 
                        sin &lt;&lt; "S";
                    if ( temp.type == 1 ) 
                        sin &lt;&lt; "R";
                    if ( temp.type == 2 )
                        sin &lt;&lt; "acc";
                    if ( temp.num != -1 )
                        sin &lt;&lt; temp.num;
                    sin &gt;&gt; temp.out;
                    printf ( "%7s%3s" , temp.out.c_str() , "|" );
                }
            }
        }
        puts ("");
    }
    for ( int i = 0 ; i &lt; (V.size()+1)*10 ; i++ )
        printf ( "-" );
    puts("");
#endif
}

void print ( string s1 , string s2 , string s3 , string s4 , string s5 , string s6 , string s7 )
{
    printf ( "%-15s|%-15s%-15s%-20s|%-15s%-15s%-15s\n" , s1.c_str() , s2.c_str() , s3.c_str() ,s4.c_str(),s5.c_str(),
                                                        s6.c_str() , s7.c_str() );                            
}

string get_steps ( int x )
{
    stringstream sin;
    sin &lt;&lt; x;
    string ret;
    sin &gt;&gt; ret;
    return ret;
}

template&lt;class T&gt;
string get_stk ( vector&lt;T&gt; stk )
{
    stringstream sin;
    for ( int i = 0 ; i &lt; stk.size() ; i++ )
        sin &lt;&lt; stk[i];
    string ret;
    sin &gt;&gt; ret;
    return ret;
}

string get_shift ( WF&amp; temp )
{
    stringstream sin;
    sin &lt;&lt; "reduce(" &lt;&lt; temp.left &lt;&lt; "-&gt;" &lt;&lt; temp.right &lt;&lt;")";
    string out;
    sin &gt;&gt; out;
    return out;
}

void analyse ( string src )
{
    print ( "steps","op-stack" ,"input","operation","state-stack" , "ACTION" , "GOTO" );
    vector&lt;char&gt; op_stack;
    vector&lt;int&gt; st_stack;
    src+= "#";
    op_stack.push_back ( '#' );
    st_stack.push_back ( 0 );
    int steps= 1;
    for ( int i = 0 ; i &lt; src.length() ; i++ )
    {
        char u = src[i];
        int top = st_stack[st_stack.size()-1];
        Content&amp; act = action[top][u];
        //cout &lt;&lt; "YES : " &lt;&lt; i &lt;&lt; " " &lt;&lt; u &lt;&lt; " " &lt;&lt; top &lt;&lt; " " &lt;&lt; act.type &lt;&lt; endl;
        if ( act.type == 0 )
        {
            print ( get_steps ( steps++ ) , get_stk ( op_stack ) , src.substr(i), "shift",  get_stk( st_stack ) , act.out , "" );
            op_stack.push_back ( u );
            st_stack.push_back ( act.num );
        }
        else if ( act.type == 1 )
        {
            WF&amp; tt = wf[act.num];
            int y = st_stack[st_stack.size()-tt.right.length()-1];
            int x = Goto[y][tt.left[0]];
            //cout &lt;&lt; y &lt;&lt; " " &lt;&lt; tt.left[0] &lt;&lt; " " &lt;&lt; x &lt;&lt; endl;
            print ( get_steps ( steps++ ) , get_stk ( op_stack ) , src.substr(i) , get_shift(tt) ,get_stk( st_stack),act.out,get_steps(x));
            for ( int j = 0 ; j &lt; tt.right.length() ; j++ )
            {
                st_stack.pop_back();
                op_stack.pop_back();
            }
            op_stack.push_back ( tt.left[0] );
            st_stack.push_back ( x );
            i--;
        }
        else if ( act.type == 2 )
        {
            print ( get_steps( steps++ ), get_stk( op_stack ) , src.substr(i) , "Accept" , get_stk(st_stack) , act.out , "" );
            //i--;
        }
        else continue;
    }
} 

int main ( )
{
    int n;
    char s[MAX];
    while ( ~scanf ( "%d" , &amp;n ) )
    {
        for ( int i = 0 ; i &lt; n ; i++ )
        {
            scanf ( "%s" , s );
            int len = strlen(s),j;
            for ( j = 0 ; j &lt; len ; j++ )
                if ( s[j] == '-' ) break;
            s[j] = 0;
            wf.push_back ( WF ( s , s+j+2 ,-1 , -1 ) );
#ifdef DEBUG
            wf[wf.size()-1].print();
#endif
        }
        make_item();
        make_first();
        make_follow();
        make_set();
        make_V();
        make_go();
        make_table();
        analyse ( "(i*i)+i" );
    }
}

</code></pre></div></div>

:ET